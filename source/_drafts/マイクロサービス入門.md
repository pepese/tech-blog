---
title: マイクロサービス入門
tags:
- マイクロサービス
id: microservice-basics
---

マイクロサービスについてまとめる。

# モノリシックの限界

アジリティが低い。

- リリース・デプロイの調整、コミュニケーション問題
- 小さなリリース、大胆な意思決定が難しい
- オーナーシップ問題があり、自律的なプロダクト開発ができない、イノベーション阻害

# マイクロサービスアーキテクチャ (MSA)

アジリティの高い開発を。

- 大きな組織でも小さな組織のような素早いプロダクト開発
- 上記を実現するようなアーキテクチャをマイクロサービスアーキテクチャ
  - 上記の文脈は削れば SOA (Service Oriented Architecture) とも見れる

- アジリティ
- 変化を許容するように計画すべき

- ボックス間で起こっていることについて心配し、ボックス内で起こっていることには寛大になる

マイクロサービスのメリデメは以下。

- メリット
  - 小さなチームへの責任と権限の委譲
  - 頻繁なトライアンドエラー
  - 高速且つ高精度な意思決定のサポート
- デメリット
  - アプリケーションはシンプルになるが、システム全体は複雑化
  - 個々のアプリケーション開発は楽になるが、全体の運用は極度に難化

デメリットを最小化して、メリットを最大化する！

# マイクロサービスの課題

- サービス同士を繋げるのが難しい（service discovery の問題）
- マイクロサービスの大きさ

# マイクロサービスの問題意識

- observability
  - Twitter 社のエンジニア発の概念
  - 分散システムをうまく運用するためにシステムの繋がり部分の挙動に注目して可視化・監視する
  - 取得すべき値や集約・ストレージの設計などがスコープ
- サービス境界の問題 -> Service Mesh
  - サービス境界で何が起こっているのか？
    - RPS、status、リトライ、タイムアウト、サーキットブレーカ、バルクヘッド、補正トランザクション
  - 分散トレーシング
    - あるリクエストを処理したサービスはどれで、その処理結果がどうだったのか
- サービス単体の可用性の確保
  - SPOFがないか -> 冗長化
  - 障害耐性/回復性は十分か -> 障害を想定した設計
- 効率的にシステム障害を解決したり、キャパシティプランニング
- 新規参入開発者が全体像を早期に把握
  - 組織の急速な成長
- オーナーシップ問題
  - 責任の分離
    - プロダクト開発社は基本的に自分たちのプロダクト・サービシに責任を持てる
  - SRE
    - しかしシステム全体は協調して動作させる必要があるので組織横断的なチームは必要
  - 横断的なチームがアプリケーションの細部を把握しなくてもシステム全体の動作を理解できる必要がある（中央で管理する必要性）

# Service Mesh

分散アーキテクチャの運用を楽に。

- Envoy ( Envoy proxy )
  - プロキシソフトウェア
- Istio
  - Envoy を統合管理するソフトウェア

## 構成

アプリケーションの代わりにネットワーク層の仕事をする。  
メトリクス取得/送信、リトライ等の実行、分散トレーシング用のログの送信、service discovery、load balancing なども行う。  
以下の2つのコンポーネントで構成される。


- data-plane
  - proxy として上記タスクを実行
- control-plane
  - 各 proxy の管理を行う

`https://speakerdeck.com/taiki45/observability-service-mesh-and-microservices?slide=38`

## 課題への対応

|対応したい障害|対処法|対処法の実装|
|:---|:---|:---|
|サービス間の一時的な障害|リトライ|サービス呼び出し失敗時に再試行|
|障害が発生しているサービスにリクエストを繰り返しリソースを消費|サーキットブレーカー|障害が発生しているサービスへのリクエストに対して早期にエラーレスポンスを返却してリソースの無駄な消費を防止|
|障害がサービス機能全体に影響することを防止|バルクヘッド|アプリケーションの構成要素をプールに分離し、1つ失敗しても他が引き続き機能できるようにする|
|複数サービスにまたがるデータ更新において結果整合性を保証|補正トランザクション|各サービスのデータ更新において、更新前の状態へ復元するための情報を残しておく。ロールバックにおいてその情報を使用|

# マクロサービスの大きさ

「十分に小さく、ちょうどいい大きさである」

- 変更する理由が同じものは集める、変更する理由が違うものは分ける
- サービスの境界をビジネスの境界に合わせる
- 2週間で書き直せるもの（10人未満のチームで）
- サービスがチーム構造と一致していること（コンウェイの法則）

# 通信方式

同期と非同期

- 同期
  - リクエスト/レスポンス
- 非同期
  - イベントベース
  - ビジネスロジックが中央に集中されず、代わりに様々なコラボレータに均等に割り振られる
- オーケストレーションとコレオグラフィ
  - Web APIたちを呼び、受け取ったデータでHTMLをレンダリングするというオーケストレーション方式
    - 呼び出されるサービス側がドメインモデル貧血症になりがちで、呼び出す側にロジックが集まっていくことになる
  - イベントをサブスクライブしていて、新規会員登録イベントが発生したら、それを受け取り、それぞれ処理を行うコレオグラフィ方式

- RX (Ractive Extensions)
- 冪等性

## プラクティス？

- DRY (Don't Repeat Yourself)
  - 1 つのマイクロサービス内では DRY を破らないけれど、すべてのサービスにわたる DRY の違反には寛大に対処する
  - ロギングライブラリなどはサービス横断で共通化してもかまわない
  - クライアントライブラリは API 開発者が提供しない（クライアントとサーバを密結合にしない）
- バージョニング
  - セマンティックバージョニング
    - MAJOR.MINOR.PATCH
      - MAJOR：後方互換性のない変更
      - MINOR：後方互換性のある追加機能
      - PATCH：既存機能のバグFIX
    - `http://semver.org/`
  - 異なるエンドポイントの共存
    - v1,v2,v3,,,
- Backend for Frontend
- トランザクション
  - 結果整合性
    - ACID -> BASE
  - 操作全体の中止
    - バルクヘッド？
  - 分散トランザクション
  - データポンプ
- デプロイ
  - ビルドパイプライン
    - コンパイルと高速テスト -> 低速テスト -> UAT(User Acceptance Testing) -> 性能テスト -> 本番環境
  - イミュータブルサーバ
  - ブルーグリーンデプロイメント
  - カナリアリリース
- テスト
  - 単体テスト
  - サービステスト
  - エンドツーエンドテスト
- 監視
  - 相関ID
- セキュリティ
  - シングルサインオンゲートウェイ

# Istio が有する機能

- ネットワーク制御
- デプロイメント方法（ブルー／グリーン、カナリアなど）
- リトライ／タイムアウト
- 負荷分散
- サーキットブレーカー
  - サービス呼び出しに対する応答に異常を発見すると、それ以降の呼び出しを遮断する仕組み
- バルクヘッド
  - アプリケーションの要素をプールに分離し、1 つの要素が失敗しても、他の要素が引き続き機能できるようにする
- 流量制御
- 障害検知
- 監視
- ログ出力

# 疑問

- サーキットブレーカー
- DDD （ドメイン駆動設計：domain driven design）
- オニオンアーキテクチャ

# 参考

- [Azure クラウド設計パターン](https://docs.microsoft.com/ja-jp/azure/architecture/patterns/)
- `https://www.slideshare.net/oracle4engineer/developers-summit-2018-kubernetes`
