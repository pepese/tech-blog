---
title: マイクロサービス入門
tags:
- マイクロサービス
id: microservice-basics
---

今更だがマイクロサービス（ Microservices ）についてまとめる。（ある程度雰囲気を知ってる人向け）

- 1.モノリシックの限界
- 2.マイクロサービスとは
- 3.マイクロサービスのデメリットへの対応
- （マイクロサービスの構成）
- （マイクロサービスへの移行）

以下について追記する必要ありか？

- 想定読者（業務SE？）
  - プロジェクトにおいてどういう立場の人向けか
  - 各章ごとに

# 1.モノリシックの限界

総じて言うとアジリティが低い。

- 小さな変更でもモノリス全体のビルド・リリース
  - リリース・デプロイの調整、コミュニケーション問題
- リソースを必要とする部分だけでなく、アプリケーション全体のスケールアウトが必要
- 小さなリリース、大胆な意思決定が難しい
- オーナーシップ問題があり、自律的なプロダクト開発ができない、イノベーション阻害

システム開発のアジリティを向上するためのアプローチの 1 つに **マイクロサービス** がある。

# 2.マイクロサービスとは

**それぞれ独自のプロセス内で動作する小さなサービスの集合体としてシステムを構成し、それらのサービス間では軽量のプロトコルを使用して通信を行うアーキテクチャー手法** を指す。  
ThoughtWorks 社の James Lewis が 2012 年 3 月に発表した[Micro services - Java, the Unix Way](http://2012.33degree.org/talk/show/67)が初出で、James Lewis/Martin Fowler が 2014 年に公開した [Microservices](https://martinfowler.com/articles/microservices.html)（[日本語](http://kimitok.hateblo.jp/entry/2014/11/09/211820)）でバズったとされる。  
どのような手法にも言えることだが、 マイクロサービスにもメリット・デメリットがあり、トレードオフの関係になっている。

## 2.1.メリット

- 開発チームがサービスごとに分かれ、それぞれ得意な最適な技術（言語など）を選択できる
- システム全体ではなく（影響を与えず）、小さなサービスごとに変更（デプロイ）できる
  - 小さなチームへの責任と権限の委譲、頻繁なトライアンドエラー、高速且つ高精度な意思決定
  - データスキーマ、メッセージスキーマ、シグネチャ、ライブラリやフレームワークのバージョン、共有コンポーネントの依存が起こらず、マイクロサービス単位で頻繁な更新をかけることが可能
- リリースサイクルの短縮
  - ビルドやテストの期間が短くなり開発効率が上がる
  - 2014年の時点で年間5000万回のデプロイ(Amazon)
- コンピュータリソースを効率的に利用
  - サービスごとに性能をスケールできる
- 再利用性
  - 1 つのマイクロサービスの機能を複数のマイクロサービスが利用できる
- 障害の分離
  - 1つの機能がダウンしてもほかの機能に影響しない、呼び出し先のサービスがダウンしても呼び出し元のサービスはダウンしない
  - モノリシックなシステムだと何か障害が起きたときに、どこがおかしいのかルート構造をたどるのに時間がかかるが、原因の突き止めが比較的容易

つまり、用途・目的ごとに小さな（マイクロな）サービスを作っておくことで、 **変化に強くて柔軟性の高い** アプリケーション開発、 **ビジネス変化への迅速な追従** が可能となる。

## 2.2.デメリット

- マイクロサービスへの分割が難しい
  - どれくらいの大きさがいいか？など
- 個々のサービスはシンプルになるが、システム全体は複雑化
  - サービス間通信が複雑化し、サービス同士を繋げるのが難しい（service discovery の問題）
- サービス間でデータの一貫性がなくなる
  - 各サービスが独自のデータベースを持つので
- 個々のサービス開発は楽になるが、全体の運用は極度に難化
  - 成熟した DevOps カルチャが必要
  - バージョン管理
- 全般的に冗長なシステムになりオーバーヘッドが多い
- 全体を見渡しにくく障害の影響を予想しにくい
- 全体のテストやデバッグがしにくい
- テクノロジーの標準を定めにくい
- サービスをまたぐトランザクションや整合性を保つしくみがない
- アジャイル開発、DevOps、インフラ運用の自動化などが前提で新しいITスキルが必要

マイクロサービスの適用においては、メリットを享受しつつ上記のデメリットを最小化することによってその効用を得ることがポイントとなる。

# 3.マイクロサービスのデメリットへの対応

ここでは、マイクロサービスのメリットを享受しつつ、 **デメリットを最小化** するためのノウハウについて記載する。  
項目は以下の通り。

- 3.1.マイクロサービスの分割
- 3.2.チームの分割
- 3.3.Design for Failure

## 3.1.マイクロサービスの分割

「十分に小さく、ちょうどいい大きさ」にする訳なのだが、以下に 4 原則を定める。

- 4 原則
  1. すべてが分散されており、
  2. ビジネスドメインを起点にサービスがモデリングされており、
  3. 各サービスが独立してデプロイでき、
  4. サービス間でデータを共有していない

上記の 4 原則に沿って、以下の観点で分割方法を記載する。

- 3.1.1.アーキテクチャ観点での分割
- 3.1.2.ビジネスドメイン観点での分割

### 3.1.1.アーキテクチャ観点での分割

プレゼンテーション層(UI/API)、ビジネスロジック層、データアクセス層（＋データベース層）に分ける。

1. レイヤードアーキテクチャ
2. ヘキサゴナルアーキテクチャ
3. オニオンアーキテクチャ
4. クリーンアーキテクチャ

### 3.1.2.ビジネスドメイン観点での分割（ドメイン駆動設計）

- 1 つのマイクロサービスで、 1 つのビジネスファンクションが完結すること
  - サービスの境界をビジネスの境界に合わせる
  - 変更する理由が同じものは集める、変更する理由が違うものは分ける
  - サービス間は疎結合

マイクロサービスの境界をうまく決める設計手法に **ドメイン駆動設計** （ **DDD : Domain Driven Design** ）がある。

「不完全な状況の中で、抽象的な設計原則を、現実のソフトウェアに適用するための助言」

#### 用語

- ドメイン
  - 知識、影響力、または活動の領域
  - ユーザーがプログラムを適用する対象エリアは、ソフトウェアのドメイン
  - つまり業務アプリケーションに限って言うなれば、「アプリケーションの対象となる業務領域」
- 境界付けられたコンテキスト（Bounded Context）
  - 特定のモデルが定義され適用される境界（通常、サブシステム、または特定のチームの作業）の説明
  - 会社全体で？プロダクト全体？もっと狭めてチームぐらいかな、という形に「この言語をこの意味で使う範囲はここまで」という風に決めましょうという概念
- ユビキタス言語
  - ドメインモデルを中心に構造化された言語
  - チームのすべてのアクティビティをソフトウェアと結びつけるために、境界付けられたコンテキスト内のすべてのチームメンバーが使用する
  - 「チームで使う共通言語」ぐらいの和訳でとらえておくのがわかりやすい

### 3.1.3.マイクロサービス分割手順

これまでの「アーキテクチャ観点での分割」「ビジネスドメイン観点での分割」を加味して、マイクロサービス分割手順を示す。

- `http://ascii.jp/elem/000/001/659/1659834/`

1. マイクロサービスの設計は、ビジネスドメインをラフスケッチし、ドメインモデルを描くことからスタートする。
2. ビジネスドメインとは、ドローン配送サービスの例では、「在庫管理」「オーダー管理」といった単位になる。「その領域内で同一の言語を話す単位（Bounded Context）。
  - 例えば、顧客管理において“顧客”が意味するものが同一である必要がある。
  - “顧客”の意味が違う領域にサービスがまたがる場合は、Bounded Contextを分離する（別のマイクロサービスにする）ように」

- オブジェクト志向
- エクストリームプログラミング

## 3.2.チームの分割

- 1 マイクロサービスで 10 人未満の 1 チーム
  - Two-pizza teams(Amazon)
  - UI担当、ミドルウェア担当、DBA のような職能でチーム分割せず、クロスファンクショナルなチームを構成
  - 2週間で書き直せるサービス（できない場合はサービスを分割する）
- サービスがチーム構造と一致していること（ **コンウェイの法則** ）
  - 購買管理チーム、在庫管理チーム、会計チーム、など

## 3.3.Design for Failure

- [品質特性](https://www.slideshare.net/yusuke/jug2015#23)

（以降、未整理）

### マイクロサービスの特徴

- 「『独立した』サービス」というのをそれぞれもう少し詳しく意味を決めておきましょう。『独立した』というのは、それが「単一でデプロイ、実行(Execute)可能である」という性質を指す
- 変化を許容するような計画・プロセスであるべき
  - 例えば Agile
- ボックス間で起こっていることについて心配し、ボックス内で起こっていることには寛大になる
- コンウェイの法則
- Reactive Manifesto
- 全てのサービス間連携はサービスインターフェイスを通じて行われるべきである
  - Amazonではこれを破ると解雇される

### マイクロサービスの問題意識（Failure）

- observability
  - Twitter 社のエンジニア発の概念
  - 分散システムをうまく運用するためにシステムの繋がり部分の挙動に注目して可視化・監視する
  - 取得すべき値や集約・ストレージの設計などがスコープ
- サービス境界の問題 -> Service Mesh
  - サービス境界で何が起こっているのか？
    - RPS、status、リトライ、タイムアウト、サーキットブレーカ、バルクヘッド、補正トランザクション
  - 分散トレーシング
    - あるリクエストを処理したサービスはどれで、その処理結果がどうだったのか
- サービス単体の可用性の確保
  - SPOFがないか -> 冗長化
  - 障害耐性/回復性は十分か -> 障害を想定した設計
- 効率的にシステム障害を解決したり、キャパシティプランニング
- 新規参入開発者が全体像を早期に把握
  - 組織の急速な成長
- オーナーシップ問題
  - 責任の分離
    - プロダクト開発社は基本的に自分たちのプロダクト・サービシに責任を持てる
  - SRE
    - しかしシステム全体は協調して動作させる必要があるので組織横断的なチームは必要
  - 横断的なチームがアプリケーションの細部を把握しなくてもシステム全体の動作を理解できる必要がある（中央で管理する必要性）

### Service Mesh

分散アーキテクチャの運用を楽に。

- Envoy ( Envoy proxy )
  - プロキシソフトウェア
- Istio
  - Envoy を統合管理するソフトウェア

#### 構成

アプリケーションの代わりにネットワーク層の仕事をする。  
メトリクス取得/送信、リトライ等の実行、分散トレーシング用のログの送信、service discovery、load balancing なども行う。  
以下の2つのコンポーネントで構成される。

- `data-plane`
  - proxy として上記タスクを実行
- `control-plane`
  - 各 proxy の管理を行う

`https://speakerdeck.com/taiki45/observability-service-mesh-and-microservices?slide=38`

### 課題への対応

|対応したい障害|対処法|対処法の実装|
|:---|:---|:---|
|サービス間の一時的な障害|リトライ|サービス呼び出し失敗時に再試行|
|障害が発生しているサービスにリクエストを繰り返しリソースを消費|サーキットブレーカー|障害が発生しているサービスへのリクエストに対して早期にエラーレスポンスを返却してリソースの無駄な消費を防止|
|障害がサービス機能全体に影響することを防止|バルクヘッド|アプリケーションの構成要素をプールに分離し、1つ失敗しても他が引き続き機能できるようにする|
|複数サービスにまたがるデータ更新において結果整合性を保証|補正トランザクション|各サービスのデータ更新において、更新前の状態へ復元するための情報を残しておく。ロールバックにおいてその情報を使用|

### 通信方式

同期と非同期

- 同期
  - リクエスト/レスポンス
- 非同期
  - イベントベース
  - ビジネスロジックが中央に集中されず、代わりに様々なコラボレータに均等に割り振られる
- オーケストレーションとコレオグラフィ
  - Web APIたちを呼び、受け取ったデータでHTMLをレンダリングするというオーケストレーション方式
    - 呼び出されるサービス側がドメインモデル貧血症になりがちで、呼び出す側にロジックが集まっていくことになる
  - イベントをサブスクライブしていて、新規会員登録イベントが発生したら、それを受け取り、それぞれ処理を行うコレオグラフィ方式

- RX (Ractive Extensions)
- 冪等性

### プラクティス？

- DRY (Don't Repeat Yourself)
  - 1 つのマイクロサービス内では DRY を破らないけれど、すべてのサービスにわたる DRY の違反には寛大に対処する
  - ロギングライブラリなどはサービス横断で共通化してもかまわない
  - クライアントライブラリは API 開発者が提供しない（クライアントとサーバを密結合にしない）
- バージョニング
  - セマンティックバージョニング
    - MAJOR.MINOR.PATCH
      - MAJOR：後方互換性のない変更
      - MINOR：後方互換性のある追加機能
      - PATCH：既存機能のバグFIX
    - `http://semver.org/`
  - 異なるエンドポイントの共存
    - v1,v2,v3,,,
- Backend for Frontend
- トランザクション
  - 結果整合性
    - ACID -> BASE
  - 操作全体の中止
    - バルクヘッド？
  - 分散トランザクション
  - データポンプ
- デプロイ
  - ビルドパイプライン
    - コンパイルと高速テスト -> 低速テスト -> UAT(User Acceptance Testing) -> 性能テスト -> 本番環境
  - イミュータブルサーバ
  - ブルーグリーンデプロイメント
  - カナリアリリース
- テスト
  - 単体テスト
  - サービステスト
  - エンドツーエンドテスト
- 監視
  - 相関ID
- セキュリティ
  - シングルサインオンゲートウェイ

### Istio が有する機能

- ネットワーク制御
- デプロイメント方法（ブルー／グリーン、カナリアなど）
- リトライ／タイムアウト
- 負荷分散
- サーキットブレーカー
  - サービス呼び出しに対する応答に異常を発見すると、それ以降の呼び出しを遮断する仕組み
- バルクヘッド
  - アプリケーションの要素をプールに分離し、1 つの要素が失敗しても、他の要素が引き続き機能できるようにする
- 流量制御
- 障害検知
- 監視
- ログ出力

### 疑問

- サーキットブレーカー
- DDD （ドメイン駆動設計：domain driven design）
- オニオンアーキテクチャ

### 参考

- [Azure クラウド設計パターン](https://docs.microsoft.com/ja-jp/azure/architecture/patterns/)
- `https://www.slideshare.net/oracle4engineer/developers-summit-2018-kubernetes`
