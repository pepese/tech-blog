---
title: RDB設計
tags:
- RDB
id: rdb-basict
---

# 3 層スキーマ

- 外部スキーマ
    - テーブルやビュー
    - ユーザから見たデータベース
- 概念スキーマ
    - テーブル定義（データの要素やデータ同士の関係）
    - 開発者から見たデータベース
    - 論理設計
- 内部スキーマ
    - テーブルやインデックスの物理定義（データファイルの物理的配置）
    - RDBMS から見たデータベース
    - 物理設計

# 内部設計

1. エンティティの抽出
2. エンティティの定義
    - データの属性、キーを定義
3. 正規化
4. ER 図の作成

# 物理設計

1. テーブル定義
2. インデックス定義
3. ハードウェアサイジング
4. ストレージの冗長性構成決定
5. ファイルの物理配置決定
    - データファイル
    - インデックスファイル
    - システムファイル
    - 一時ファイル：サブクエリの展開やソートデータ
    - ログファイル

||用途|ユーザアクセス|データ量増加|性能考慮|
|:---|:---|:---|:---|:---|
|データファイル|テーブルデータの格納|有|有|高|
|インデックスファイル|インデックスの格納|有|有|高|
|システムファイル|管理用データの格納|無|有|低|
|一時ファイル|一時データの格納|無|無|高|
|ログファイル|更新ログの格納|無|無|中|

# バックアップ設計

|項目|フルバックアップ|差分バックアップ|増分バックアップ|
|:---|:---|:---|:---|
|バックアップ対象データ|すべて|前回フルバックアップからの差分|前回任意のバックアップからの差分|
|バックアップ処理時間|大|中|小|
|リカバリ処理時間|小|中|大|

# 論理設計と正規化

## 制約

- NOT NULL 制約
- 一意制約
- CHECK 制約

## 正規化

冗長性と非一貫性を排除する。  
レベル 5 まであるが、 3 までで十分。

- 第 1 正規形
    - 1 つのセルには 1 つの値しかない
- 第 2 正規形
    - 部分関数従属を解消し、完全関数従属になった形
- 第 3 正規形
    - 推移的関数従属を解消した形
- ボイスコット正規形
- 第 4 正規形
- 第 5 正規形

# パフォーマンス

RDB のパフォーマンスを決める要因は主に以下の 2 つ。

- インデックス
- 統計情報

## インデックス

インデックスは主に B-Tree で構成される。  
インデックスは以下の列に作成する。

- 大規模なテーブルの列
- カーディナリティの高い列
    - カーディナリティ：取りうる値のバリエーション数
- where 句の選択条件、結合条件

以下の場合、インデックスが使用されないので注意が必要。

- インデックス列に演算を行なっている
- インデックス列に対して SQL の関数を適用している
- インデックス列に対して IS NULL 術後を使用している
- インデックス列に対して 否定形 を使用している
- インデックス列に対して OR を使用している
- インデッックス列に対して、後方一致、中間一致の LIKE を使用している
    - 前方一致は大丈夫
- インデックス列に対して 暗黙の型変換を行なっている

その他の注意点には以下がある。

- 主キー、一意制約列にはインデックス作成不要
- インデックスは検索性能は上がるが、更新性能は下がる
- 定期的なメンテナンスを行うことが望ましい

## 統計情報

いわゆる **オプティマイザ** と **実行計画** 。  
以下のように処理される。

1. パーサ
    - SQL を受け取り、構文チェックする
2. オプティマイザ
    - カタログマネージャにアクセスする
3. カタログマネージャ
    - 統計情報を管理し、オプティマイザに渡す
4. オプティマイザ
    - カタログマネージャから得た統計情報から最短経路を選択する（実行計画、実行プラン、アクセスプラン）

統計情報は RDBMS により自動で更新されるため、データが大きく更新された後なるべる早く確認する必要がある。  
統計情報をある時点で凍結・固定する、という戦略もある。

## パフォーマンスのその他の話題

- 正規化のトレードオフ
    - 正規化すると更新性能はあがるが、 **テーブル結合** を伴う参照性能は低下する
- テーブル分割
    - 水平分割
        - レコードの分割、いわゆるシャーディング
        - I/O ネック解消のために実施される
        - RAID や RDBMS の機能である **パーティショニング** を使用する方がいい
    - 垂直分割
        - 列の分割
        - 集約（合計、平均など）のデータが欲しい場合に実施される
        - ある目的のために垂直分割されたテーブルを **データマート** （単に **マート** ）とよぶ
            - データの同期がネックになる
        - 集約結果のテーブル（ **サマリテーブル** ）を作成するのも手

# SQL

## CASE 式

```
case when sex = '1' then '男'
     when sex = '2' then '女'
else 'その他' end
```

注意点は以下。

1. 分岐が返却するデータ型を統一する
2. `end` 、 `else` を忘れない

集計関数内や `check` 句、条件別の `update` などにも利用できて便利。