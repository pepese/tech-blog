---
title: 新しいプログラミング言語を学ぶ方法
tags:
- プログラミング言語
- 学習
id: learning-new-programming-language
---

Golang やってみようかなと思って自分なりに学習方法まとめてみた。  
Golang に特化した方法ではない。

1. 公式サイトか何かで基本文法を学ぶ
2. アルゴリズムを実装してみる
    - ソート、探索アルゴリズムなど
3. コードリーディング
    1. その言語で実装された好きな OSS を選ぶ（できれば自分がよく使うもの、小さいもの）
    2. その OSS を利用者として使ってみる（機能の全体像を把握する）
        1. ソースからビルドしてみる（ソフトウェアの構成がわかる）
            - その言語でコンパイル、ビルド、依存関係管理などのツールエコシステムが見えてくる
            - Github 上の OSS であれば `CONTRIBUTING.md` 的なところにビルドとかテスト方法書いてある
        2. 一通りチュートリアル的なもので機能を理解する（コードリーティングの時に理解が捗る）
    3. コードを読んでみる
        1. main 関数的なエントリポイントを見つけて、そこから読む（複数ある場合は興味のあるものから）
        2. わからない表現は随時しらべる
            - よく利用される標準ライブラリやデファクトライブラリが見えてくる
        3. どうしてもよくわからないところは部分的に動かしてみる
            - ユニットテストツールを使うことになるかも（主要なテスティングツールを知る）
            - ソフト全体をデバッグ実行して処理を追ってもいいがソフトのサイズによってはしんどい（主要なデバックツールを知る）
        4. PR なんか出してみてもいいw
4. 自分で何か作ってみる
    - 学習目的であれば、よくあるアプリやツールなど仕様丸々コピーで作ってみる
        - Web 系の人は 主要な Web フレームワークや ORM などを使って簡単な EC サイトとかいいかも
    - 「ちょっと小遣い稼ぐか」などという雑念が入ると手が止まるので注意
    - TDD（Red -> Green -> Refactor）やデザインパターンを意識して作れるとよい
        - テスティングツールの使い方がわかる、言語固有の記述パターンを知る

これであなたも Golang スペシャリスト？w

# 上の順でやってるメモ

3-2-1実施中。  
ビルドはえぐそうなのでビルドのコードを追って以下のことがわかった。  
Kubernetes をビルドして作成されるもの一覧。各々に `package main` `func main` あり。

- https://github.com/kubernetes/kubernetes/blob/master/build/BUILD

```
release_filegroup(
    name = "docker-artifacts",
    srcs = [":%s.tar" % binary for binary in DOCKERIZED_BINARIES.keys()] +
           [":%s.docker_tag" % binary for binary in DOCKERIZED_BINARIES.keys()],
)

# KUBE_CLIENT_TARGETS
release_filegroup(
    name = "client-targets",
    srcs = [
        "//cmd/kubectl",
    ],
)

# KUBE_NODE_TARGETS
release_filegroup(
    name = "node-targets",
    srcs = [
        "//cmd/kube-proxy",
        "//cmd/kubeadm",
        "//cmd/kubelet",
    ],
)

# KUBE_SERVER_TARGETS
# No need to duplicate CLIENT_TARGETS or NODE_TARGETS here,
# since we include them in the actual build rule.
release_filegroup(
    name = "server-targets",
    srcs = [
        "//cluster/gce/gci/mounter",
        "//cmd/cloud-controller-manager",
        "//cmd/hyperkube",
        "//cmd/kube-apiserver",
        "//cmd/kube-controller-manager",
        "//cmd/kube-scheduler",
    ],
)

# kube::golang::test_targets
filegroup(
    name = "test-targets",
    srcs = [
        "//cmd/gendocs",
        "//cmd/genkubedocs",
        "//cmd/genman",
        "//cmd/genswaggertypedocs",
        "//cmd/genyaml",
        "//cmd/kubemark",  # TODO: server platforms only
        "//cmd/linkcheck",
        "//test/e2e:e2e.test",
        "//test/e2e_node:e2e_node.test",  # TODO: server platforms only
        "//vendor/github.com/onsi/ginkgo/ginkgo",
    ],
)

# KUBE_TEST_PORTABLE
filegroup(
    name = "test-portable-targets",
    srcs = [
        "//hack:e2e.go",
        "//hack:get-build.sh",
        "//hack:ginkgo-e2e.sh",
        "//hack/e2e-internal:all-srcs",
        "//hack/lib:all-srcs",
        "//test/e2e/testing-manifests:all-srcs",
        "//test/kubemark:all-srcs",
    ],
)
```

上記の `main` のそれぞれの配置（クライアント、MasterNode、WorkerNode）、機能概要を調べて、どの `main` を読むか決める。  
実際にコンテナ作ってるところが見たいなぁ、、、

## クライアントツール

- `kubectl`
    - マニフェストの設定を `kube-apiserver`  へ送信する

## サーバ

### Master Node

- `kube-apiserver`
    - kubectl から設定情報を受け付けて、 クラスタが保持すべき状態として情報を `etcd` へ保存する
    - apiserver 以外のコンポーネントは直接 etcd を参照せず、 apiserver を通してリソースにアクセスする
- `etcd`
    - 全てのクラスタデータを保持する
- `kube-scheduler`
    - 新しい Pod を作成し、 Woker Node を選択・配置する
- `kube-controller-manager`
    - `etcd` の情報とクラスタの現在の状態を比較し、 `etcd` の状態へ更新する（ apiserver 経由での参照）
    - controller は自作可能
    - controller は複数プロセス存在するが、バイナリは 1 つにまとめられる
        - Node Controller: Worker Node の停止を検出する
        - Replication Controller: Pod の数を制御する
            - Replication Controller はリソース名自体に"Controller"とつくため、コントローラーは"RepplicationManager"という名前
        - Endpoints Controller: Service や Pod 内のエンドポイントオブジェクトを設定する
        - Service Account & Token Controllers: namespace のデフォルトアカウント、API アクセストークンを作成する
    - 各 controller は goroutine で起動
- `cloud-controller-manager` （α版）
    - クラウドプロバイダのリソースをコントロールする
- `hyperkube`
    - Kubernetes関連のバイナリを1つにまとめたall-in-oneバイナリ

## Worker Node

- `kubelet`
    - クラスタ内のそれぞれの Worker Node で稼働するエージェント（ Worker Node のメイン処理）
    - PodSpecs の設定を提供し、コンテナが Pod 内で稼働していることを管理する
- `kube-proxy`
    - ホスト上のネットワークルールを維持し、接続転送を実行することによって、Kubernetesサービスの抽象化を可能にする
- Container Runtime
    - コンテナの実行環境
    - `Docker` `rkt` `runc` など

## Addons

- https://kubernetes.io/docs/concepts/overview/components/#addons

- Kubernetes 公式ドキュメントの全て
    - https://kubernetes.io/docs/home/?path=users&persona=app-developer&level=foundational
- a
    - https://qiita.com/tkusumi/items/c2a92cd52bfdb9edd613