---
title: ブロックチェーン入門
tags:
- blockchain
id: blockchain-basics
---

# ブロックチェーンの特徴

- P2P ネットワーク
    - コンピュータ（ノード）同士が同じ目的で接続し、ネットワークを形成する方式
    - どのノードでも同じ処理ができるので、ネットワーク全体におけるノードの少数台が停止しても全体には影響しない
    - 以下の種類がある
        - ピュア P2P 型：他ノードの探索が自律的、探索アルゴリズムが必要
        - ハイブリッド P2P 型：他ノードの探索にインデックスサーバを用いる
- 分散型台帳
    - 同じ台帳データが複数ノードに配備されているシステム
    - 複数組織間でのコンセンサス、台帳のトレーサビリティにコストがかかっていた領域にメリット
    - 処理完了までの遅延などにデメリット
- ビザンチン将軍問題
    - 分散システムにおいてタイムラグ、未到達、改竄、二重送信などによって偽の情報を伝達する可能性がある場合に、全体として正しい合意を形成できるかを問う問題
- トレーサビリティと透明性
    - ブロックチェーンは最新の情報だけでなく、過去の取引履歴も全て記録されておりトレーサビリティおよび取引の透明性がある
- データの改竄が困難
    - 詳細は後述するが、ブロックチェーンを改竄するには膨大な計算量が必要であり、リソース的に困難な仕組みになっている
- 合意形成アルゴリズム/コンセンサスアルゴリズム
    - ビザンチン将軍問題を解決する仕組み、承認者のノード間で合意形成をする仕組み
- スマートコントラクト
    - その名前の通り、コントラクト（契約）をスマートに行えるプロトコルのこと
- ブロックチェーン基盤の分類：パブリック、プライベート、コンソーシアム
    - パブリック型：管理者を置かず、誰でもネットワークに参加可能
    - コンソーシアム型：複数のパートナー企業が管理者とされ、ネットワークへの参加には管理者の許可が必要
    - プライベート型：

||パブリック型|コンソーシアム型|プライベート型|
|:---|:---:|:---:|:---:|
|（マイニング）ノード型|制限無|制限可|制限可|
|ブロックチェーンの閲覧|制限無|制限可|制限可|
|ブロック生成時|高難易度な仕組み必須|任意|任意|
|マイニング報酬|必須|任意|任意|


[まとめ記事](https://qiita.com/akitoh/items/bebf1bf3d71d3e4b96b0)  
[まとめ資料](http://www.digitalmoney.or.jp/wp-content/uploads/2016/04/201604_BlockChain2.0_v06.pdf)

# 合意形成アルゴリズム/コンセンサスアルゴリズム

以下のようなアルゴリズムがある。  
アルゴリズムが使用できる OSS やブラットフォームも挙げる。

- PoW （ Proof of Work ）
    - Bitcoin Core 、 Ethereum などで使用される
- PoS （ Proof of Stake ）
    - Ethereum 、 mijin などで使用される
- PBFT （ Practical Byzantine Fault Tolerance ）
    - Hyperledger Fabric で使用される

## PoW （ Proof of Work ）

取引記録を P2P ネットワークで受信した参加者たちは受け取った取引記録の承認作業を行う。  
確率的に解答が困難な問題を一番早く解いた（ **Proof of Work** ）人にブロックの生成を許可し、その報酬としてインセンティブが得られる。  
また、通信の断絶状態などによって不整合が生じ、チェーンが分岐した場合は一番長いチェーンを正とすることでデータの一貫性を保証する。  
以下の問題が存在する。

- 51% 問題
    - 特定の人物・組織が所有するマイナーが過半数を占めた場合、結果を自由に操作できる
- ファイナリティの不確実性
    - チェーンが分岐し、短い方を正としていたノードが長い方へ切り替わった場合、自分の口座残高が急に変化したり、取引自体が無くなったりする
    - ビットコインでは、取引が確定しても 6 ブロック待たないと次の取引が実行できないといった制限で発生確率を下げている
- 性能限界
    - ネットワーク伝搬時間を無くすことは不可能で性能を上げることが難しく、リアルタイム性の高い業務には不向き
- ブロックチェーンの容量
    - 全てのノードが全てのブロック情報を保有する必要がある

## PoS （ Proof of Stake ）

基本的に PoW と変わらないが、貨幣量を多く所有している承認者が優先的にブロックを生成できるという特徴がある。  
これは、「大量の通過を所有している参加者は、その貨幣価値を守るためにシステムの信頼性を損なうことはしないであろう」という前提に基づく。

## PBFT （ Practical Byzantine Fault Tolerance ）

PoW や PoS が持つ問題であった「ファイナリティの不確実性」に対応した方式。  
ネットワークへの参加者をあらかじめ知っている前提で、 1 人がプライマリ（リーダ）となり、全参加者へ要求を送り、多数を占める値でブロックを確定させる。条件を満たさない取引は確定されない。  
この方式ではプライマリが処理の確定を行うので、ブロックチェーンが分岐しない。  
デメリットとしては、常に全ノードと意思疎通を行うため、ノードの追加とともに通信量が加速度的に増加するため、ネットワークとしては数十ノードが限界。

# ブロックチェーンの構造

- トランザクション
    - 一回の取引
    - なお、 トランザクションには電子署名が付与される
- 電子署名
    - トランザクションで取引をする対象の本人確認と改竄防止
- ブロック
    - 一定時間溜まった、あるいは一定数のトランザクションをまとめた 1 つの塊、台帳の 1 ページ
    - 1 つのブロックにはトランザクションだけでなく後述のハッシュ、ナンスも含まれる
- ブロックチェーン
    - ブロックを時系列に単方向リストのように連ねた台帳
- ハッシュ
    - 前のブロックの取引内容を要約したもの
- ナンス（ nonce ）
    - ハッシュ計算で求められるパラメータ

## 改竄が困難な理由

ブロックチェーンでは最新のデータが保持されるだけでなく、  **過去の取引の履歴** が過去のブロックに保持されている。  
仮に過去の取引・ブロックを改竄した場合、その次のブロックのハッシュが変更となる。  
すると、そのブロックのナンスもハッシュに基づいて再計算する必要があり、後続のブロック全てについてもハッシュ・ナンスを再計算しなければ整合性がとれなくなる。  
ブロックチェーンにおいて改竄を成立させるためには、正当に伝搬しているブロックよりも早くブロックを成立させるか、過去のブロックを全て作り直す必要があり、計算量的に改竄が困難な仕組みになっている。

## 電子署名による偽造、改竄防止

# OSS

https://qiita.com/kyrieleison/items/ec5223bbe6140822df4a

- Hyperledger Fabric
- Ethereum （イーサリアム）
- Chain

## Hyperledger Fabric

https://www.slideshare.net/Hyperledger_Tokyo/hyperledger-fabric-10

Hyperledger Fabric（ハイパーレッジャー ファブリック）は、 Hyperledger といいう ブロックチェーン技術推進コミュニティ により共同検証された OSS で単に Fabric と呼ばれる。  
The Linux Foundation のプロジェクトの 1 つで Hyperledger Project 。  
Fabric の特徴は以下の通り。

- Industry-focused Design
    - ブロックチェーンは元々不特定多数を対象としたビットコインに利用される技術であったが、知っている者同士で契約を行う場面などビジネスにおける多様なユースケースに応える設計となっている
    - 参加者の登録と証明書発行、権限設定を担うメンバーシップ・サービスを実装しており、トランザクションは個々の参加者の証明書を用いて暗号化されています。プライベートな複数のブロックチェーンネットワークを有効にすることもできます。
- Modular Architecture
    - **メンバーシップサービス** 、 **ブロックチェーンサービス** 、 **チェーンコードサービス** という3つのカテゴリのコアコンポーネント
    - 個別のプロセス・名前空間・仮想マシンを持った物理的な個々の部品になっており、それぞれプラグアンドプレイが可能
    1. メンバーシップサービス
        - 参加者のアイデンティティと権限を管理
        - 参加者に対して登録証明書(Enrollment Certificates, ECert)や取引証明書(Transaction Certificates, TCert)を発行する認証局(CA)の役割を担う
    2. ブロックチェーンサービス
        - HTTP/2 上に構築された P2P プロトコルを通じて、ブロックチェーンとトランザクションを管理
        - 異なるコンセンサス・分散合意形成アルゴリズム(PBFT, Raft, PoW, PoS)にプラグイン可能で、デプロイ毎に設定
    3. チェーンコードサービス
        - ブロックチェーンにトランザクションの一部として保存されるアプリケーションレベルのコード
        - 各ノードでトランザクションを実行する方法(= チェーンコードの実行環境)を提供する
        - 実行環境は OS と言語、Runtime と SDK をセットにした Docker イメージになっており、Go, Java, Node.js をサポート

[公式サイト](https://www.hyperledger.org/)  
[公式 Github リポジトリ](https://github.com/hyperledger/fabric)  
[公式ドキュメント](http://hyperledger-fabric.readthedocs.io/)

## 構成

- クライアント
    - 全PeerにTransaction Proposal(トランザクションのお伺い)を送って署名を集める
    - Ordererにトランザクションと署名とreadset/writeset*を送る
- Membership Service Providers
    - ユーザー認証や証明書の発行
    - ネットワークに複数存在(Org毎に1つ)
    - ※詳細は [こちら](http://hyperledger-fabric.readthedocs.io/en/latest/msp.html)
- Orderer
    - Proposal response(トランザクション+署名+readset/writeset*)複数Channelでリクエストを受け付ける
    - ブロック(トランザクション+署名+readset/writeset*)作成および整列
    - Channelに参加しているPeerにブロックを配布
- Peer
    - チェーンコード実行(台帳書き込みの代わりにreadset/writeset*を生成)および署名を実施
    - Ordererから受け取ったブロックで台帳書き込み
    - ※チェーンコード実行後に即台帳書き込み、ではないので注意

> - readset/writeset:
>     - readset: Peerがチェーンコードを実行した時点でのワールドステートのバージョン(キー毎)
>     - writeset: ワールドステートの更新内容

## リクエストの流れ

クライアント->Peer->クライアント->Orderer->Peer 。

1. クライアントは自分が所属するOrganizationのMSPでEnrollし、Peerとの通信に必要な証明書を取得する
2. クライアントはPeerにTransaction Proposalを送る
    - 台帳書き込みを伴う場合はEndorsement policyを満たすよう複数Peerに送信
3. Peerがチェーンコードを実行し、署名とreadset/writesetを生成してクライアントに返す
    - ※Queryの場合は台帳検索結果が返ってくる。台帳書き込みを伴わないのでここで終了
4. クライアントは各Peerからの戻りと元のトランザクションをまとめてOrdererに送る
5. Ordererは複数クライアントからのリクエストをChannel毎に整列してブロックを生成し、Channelに参加しているPeerに配布する
6. 各Peerで下記を確認してから台帳書き込みを実行
    - ブロックに含まれている署名がEndorsement policyを満たしていること
    - readsetのワールドステートのバージョンが最新であること
7. 各Peerが台帳書き込み完了イベントをクライアントに通知

## 疑問メモ

- LevelDB
    - インデックスのDB？
    - 検索を高速化する仕組みのはず

State databese には LevelDB と CouchDB が含まれる。  
LevelDB は デフォルトの key-value 。  
CouchDB はオプションの代替外部状態データベース。  
検索などの行為は CouchDB （ドキュメント型： JSON ）へ直接行う？

If you model assets as JSON and use CouchDB, you can also perform complex rich queries against the chaincode data values, using the CouchDB JSON query language within chaincode.  
チェインコードから直接 CouchDB へリッチなクエリを発行できる？  

[上記に関する公式 Doc](https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_as_state_database.html)

## CouchDB について

REST ベース。

- リビジョン番号
    - ドキュメントは削除されずに追加のみ
    - DocID + RevID （リビジョン番号）で一意
    - DocID のみ指定で最新が取得される

```
{"id":"hoge", "name":"test", "rev":"1-123"}
```

- ドキュメント追加
    - POST は DocID 自動採番
    - PUT は DocID 指定
- 一覧取得
    - `GET /menbers/_all_docs`
    - `_all_docs` は予約語
- **view** とは？
    - クエリを発行したり、レポートを作ったりする機能
    - 1 つの **view 属性** は 1 つの **map** を持ち、オプションで 1 つの **reduce** を持てる
    - いくつかの view 属性が 1 つの **デザイン・ドキュメント** に格納される
    - `{dbName}/_design/{デザイン名}/_view/{view名}`

## SDK の機能

- fabric client
- fabric-ca client

key-value なので、 key 指定でしか検索できない？

```
Successfully queried  chaincode function: request={"chaincodeID":"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","fcn":"query","args":["a"]}, value=90
```

## 環境構築

Fabric での環境構築を実施する。

