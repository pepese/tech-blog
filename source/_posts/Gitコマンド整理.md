---
title: Gitコマンド整理
date: 2017-05-11 13:15:09
tags:
- Git
id: git-commands
---

以下のような感じでGitコマンド、概念を整理する。

- 環境設定
- Gitの保存領域
- 変更を保存する
- 変更の状況を確認する
- 変更を戻す
- リモートリポジトリから情報を取得する
- ブランチ操作
- その他の操作

<!-- more -->

# 環境設定

- `git init`
  - ローカルリポジトリの作成
- `git config`
  - Gitクライアントの設定
  - `--global` で全体に反映される設定、 `--local` で個別プロジェクトに反映される設定
    - `--local` の方が強い
- `git remote`
  - `git init` した後にリモートリポジトリの設定を行う

# Gitの保存領域

Gitの以下の保存領域がある。

- **ワーキングディレクトリ** / **ワークツリー**
  - 作業スペース。編集中のファイルがある。
- **ステージングエリア** / **インデックス**
  - コミットする内容をた保存するスペース。
- **ローカルリポジトリ**
  - コミットするとステージングエリアの内容が保存される。
  - 開発者のローカルPCに作成される領域。
- **リモートリポジトリ**
  - ローカル以外のすべてのリモートリポジトリ。
  - githubなどが代表例。

# 変更を保存する

ファイルの変更は、 **ワーキングディレクトリ** -> **ステージングエリア** -> **ローカルリポジトリ** -> **リモートリポジトリ** と段階的に保存することができる。  
以下のコマンドで実行できる。

- `git add <file_name>` / `git add <file_name> <file_name> ...` / `git add --all`
  - 所謂、 **ステージング**
  - **ワーキングディレクトリ** の変更を **ステージングエリア** へ保存する
  - `--all` オプションでワーキングディレクトリの全ての変更をステージング
- `git commit`
  - 所謂、 **コミット**
  - **ステージングエリア** の変更を **ローカルリポジトリ** へ保存する
  - コミット時にはコミットメッセージを記載する必要がある（ `-m` オプションで指定可能）
  - この際、 **コミットID** が払い出される
- `git push`
  - **ローカルリポジトリ**の変更を **リモートリポジトリ** に保存する

## コミットID

コミットを実行した際、そのコミットの変更に対して40桁の一意なIDが払い出される。  
これが **コミットID** 。（以降、 `<commit_id>` とも表現）  
このコミットIDには以下のようなエイリアスが用意されている。

- `HEAD`
  - 最新のコミットID
- `HEAD^`
  - `HEAD` の1つ前のコミットID
- `HEAD^^`
  - `HEAD` の2つ前のコミットID

## 保存対象から除外する

- `git rm`
  - ワーキングディレクトリにあるファイルとステージングエリアのファイルを削除する

# 変更の状況を確認する

- `git status`
  - **ワーキングディレクトリ** と **ステージングエリア** の変更状況を確認することができる
  - **ワーキングディレクトリ** と **ステージングエリア** の差分を確認する際に有効
  - 以下の状態がある
    - `Untracked files:`
      - **ステージングエリア** にも **ローカルリポジトリ** にもこれまで存在していない **ワーキングディレクトリ** に存在するファイル
    - `Changes not staged for commit:`
      - これまで **ステージングエリア** 、 **ローカルリポジトリ** に存在していたファイル
      - `modified:` は変更が加えられたがステージングされていないファイル
      - `deleted:` は削除されたがステージングされていないファイル
    - `Changes to be committed:`
      - **ステーイング** されているが、 **ローカルリポジトリ** に反映されていないファイル
      - `modified:` は変更が加えられたがコミットされていないファイル
      - `deleted:` は削除されたがコミットされていないファイル
- `git diff`
  - **ステージングエリア** と **ローカルリポジトリ** を比較することができる。  
  - ファイルの中身の差分まで確認することができる。
- `git log`
  - コミットによるローカルリポジトリの変更履歴を表示する
  - コミットID、編集者、変更内容などが表示される

# 変更を戻す

- `git clean`
  - **ステージング** していない **ワーキングディレクトリ** の変更を戻す
  - **ワーキングディレクトリ** を **ステージングエリア** の状態に戻す
- `git commit --amend`
  - 最新のコミットをやり直す
  - 最新のコミットを削除して、現在のステージングエリアの状態で際コミットする
  - 「コミットメッセージを間違えた」「コミットにファイルを含め忘れた」際などに使用
- `git reset <commit_id>`
  - 指定したコミットID以降のコミットをなかったことにする
  - 後述の `git revert` は打消し処理も履歴として残る（以降のコミットをなかったことにしない）が、 `git reset` は取消しの履歴も残らない
  - `<commit_id>` を省略した場合は `HEAD` を指定したことになる
  - 例： `git reset --hard HEAD^` ：現在のブランチHEADの１つ前の状態に戻る、前のHEADはなくなる、ワーキングディレクトリも戻る
  - 例： `git reset <commit id>` ：現在のブランチの位置を `<commit id>` まで戻しつつステージングエリアもそのときの状態に戻す、ワーキングディレクトリはそのまま、 `--hard` をつけるとワーキングディレクトリも戻る

resetには「 **soft** 」、「 **mixed** 」（デフォルト）、「 **hard** 」の３つのモードがありそれぞれ下表のようになる。

|モード（オプション）|HEADの位置|ステージングエリア|ワーキングディレクトリ|
|:---:|:---:|:---:|:---:|
| `--soft`  |変更する|変更しない|変更しない|
| `--mixed` |変更する|変更する  |変更しない|
| `--hard`  |変更する|変更する  |変更する|

- `git reset <file>`
  - ステージングエリアに追加されたファイルの変更をステージングエリアから削除する、ワーキングディレクトリはそのまま
  - あるステージングエリアのファイルの状態をローカルリポジトリの `HEAD` と同じ状態にする、という意味
- `git revert <commit id>`
  - 指定コミットで加えられた変更を打ち消し、元に戻す新しいをコミットを生成・適用する
  - `git reset` はコミット履歴を削除するが、 `git revert` は指定のコミットIDで加えられた変更を元に戻す変更を新たにコミットするのでコミット履歴は残る
- `git checkout <commit id> <file_name>`
  - **ワーキングディレクトリ** が指定した **ローカルリポジトリ** のコミット時の状態と同じになる
  - **ステージングエリア** の保存状態が削除されることに注意

# リモートリポジトリから情報を取得する

- `git clone`
  - リモートリポジトリからローカルリポジトリを複製
  - `git clone --mirror`
    - リモートリポジトリのミラーリングを行う、バックアップに使う
- `git pull`
  - リモートリポジトリから変更を取得する（マージまで行う）
  - 「`git fetch` + `git merge origin/master`」に同じ
- `git fetch`
  - リモートリポジトリから最新の変更情報を取得する（マージは行わない）
- `git merge`
  - `git fetch` で取得したリモートリポジトリの最新情報をローカルリポジトリへ取り込む

## *master* と *origin/master* の違い

*master* はローカルリポジトリのmasterブランチを指し、 *origin/master* はリモートリポジトリのmasterブランチを指す。  
ただし、 *origin/master* はリモートリポジトリと結びついているブランチであって、ローカルに存在する。  
`git fetch` することによって、ローカルの *origin/master* が更新される。  
つまり、 `git fetch` した後に `git merge origin/master` すると、「ローカルの *master* ブランチに最新状態に更新した *origin/master* の変更をマージする」ということになる。


# ブランチ操作

- `git branch`
  - ブランチの一覧を表示する
- `git branch <branch_name>`
  - ブランチを作成する（現在のブランチのリビジョンで作成される）
- `git branch -d <branch_name>`
  - ブランチを削除する
- `git checkout <branch_name>`
  - 指定したブランチに切り替える
  - ワーキングディレクトリも指定したブランチの状態になる
  - リビジョンの指定も可能
    - `git branch <branch_name>/<revision>`
- `git merge`
  - マージ（masterからnewBranchを取り込む）
  - `git merge <branch_name>`
    - 今のブランチに指定したブランチをマージする
    - コンフリクトが発生するとコンフリクトが発生したファイルを修正してaddとcommit（メッセージは自動生成）を実行する必要がある
- `git rebase <branch_name>`
  - 指定したブランチのHEADに現在のブランチの変更を追加する
  - `git rebase master`
    - 現在のブランチをmaster(HEAD)から作成したことにする
  - 競合が発生した場合は修正の後`git rebase --continue`を実行する

# その他の操作

- `git tag`
  - タグを作成する
- `git blame <file_name>`
  - 対象ファイルを行単位で誰がいつ修正したのか表示
- `git stash`
  - コミットしていない変更を一時的に保存してブランチを切り替える
